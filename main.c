#pragma config FOSC  = HS       // Oscillator Selection bits (XT oscillator)
#pragma config WDTE  = OFF      // Watchdog Timer Enable bit (WDT enabled)
#pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
#pragma config BOREN = OFF      // Brown-out Reset Enable bit (BOR disabled)
#pragma config LVP   = OFF     // Low-Voltage (Single-Supply) In-Circuit Serial Programming Enable bit (RB3 is digital I/O, HV on MCLR must be used for programming)
#pragma config CPD   = OFF      // Data EEPROM Memory Code Protection bit (Data EEPROM code protection off)
#pragma config WRT   = OFF      // Flash Program Memory Write Enable bits (Write protection off; all program memory may be written to by EECON control)
#pragma config CP    = OFF      // Flash Program Memory Code Protection bit (Code protection off)

#define _XTAL_FREQ 8000000

#include <stdio.h>
#include <stdlib.h>
#include <xc.h>

//#define RE_DE    RE2
//#define LED_DATA PORTD
//#define LED_CTRL PORTA
#define COMMAND 0
#define DATA 1
#define LCD_EN PORTEbits.RE1
#define LCD_RS PORTEbits.RE2
#define LCDPORT PORTD
#define LCDPORT_DIR TRISD
#define LCD_EN_DIR TRISEbits.TRISE1
#define LCD_RS_DIR TRISEbits.TRISE2
#define L_ON 0x0F
#define L_OFF 0x08
#define L_CLR 0x01
#define L_L1 0x80
#define L_L2 0xC0
#define L_CR 0x0F
#define L_NCR 0x0C
#define L_CFG 0x38
#define L_CUR 0x0E
#define RS485_TX_EN     RC0     // Transmit enable pin
#define RS485_RX_EN     RC1     // Receive enable pin


// Functions ------------------------------------------------------------------

void __interrupt() ISR();
void Timer0_Init(void);

void UART_Init(void);
void RS485_TxEnable(void);
void RS485_RxEnable(void);
void UART_Write(char data);
void UART_Read(void);

unsigned char GenerateRandomNumber(void);

void checkMessage(void);

void ResetGlobalVariables(void);

// init KeyPad
void KeyPadReader();
void KeyPressed(unsigned char);

void initLCD(void);
void lcdSend(char, char);
void lcdPrint(char *);
void intToString(int, char *);
char potenza(char, char);


// Global variables and constants --------------------------------------------

const unsigned char colMask[3] ={
    0b11111110,
    0b11111101,
    0b11111011
};
const unsigned char rowMask[4] ={
    0b00000001,
    0b00000010,
    0b00000100,
    0b00001000
};

const unsigned char keys[] = {'=', '7', '4', '1', '*', '8', '5', '2', '0', '9', '6', '3'};
unsigned char keypressed = 0; 
char keyok = 0;

unsigned char colScan = 0;
unsigned char rowScan = 0;
static __bit old_btn;
char stato = 0;
char old_stato = 0;

// To print numbers as strings
char stringa[16];
int stringPosition = 0;


unsigned char start = 0;    // When true, it starts the program (after user presses *)
unsigned char resetGlobalVariables = 0; // When true, is it used to reset all the global variables and restart the program

const unsigned char gatewayId = 0x00;     // The gateway id is a constant
const unsigned char myUniqueId = 0x09;    // My id is also a constant
unsigned char messageType;

// Buffer to receive messages from the serial port
char buffer[50];
char received;
int bufferIndex;

// Code generated by PIC
unsigned char deviceGeneratedCode[5];
int deviceGeneratedCodeIndex = 0;

// Code inserted on keypad by user
unsigned char codeFromKeypad[5];
int codeFromKeypadIndex = 0;

// Counter to set the position at which chars have to be printed on second line
int secondLineLcdPosition = 9; // To print after "Insert: "

// Confirmation codes to open the door or not
const unsigned char openDoorCode = 0x01;
const unsigned char doNotOpenDoorCode = 0x02;
const unsigned char errorCode = 0x03;



void main()
{
    TRISA=0x00;	   
	TRISB=0x00;
	TRISC=0x00;
	TRISD=0x00;
    TRISE=0X00;
    UART_Init();
    initLCD();
    Timer0_Init();
    while(1)
    {
        lcdSend(L_CLR, COMMAND);
        lcdPrint("Press *");
        // Create random numbers
        for (int i = 0; i < 5; i++)
        {
            deviceGeneratedCode[i] = GenerateRandomNumber();
        }
        while (!start)
        {   
            KeyPadReader();
        }
        lcdSend(L_CLR, COMMAND);
        lcdPrint("Wait...");
        // Change randomly the values for every number
        for (int i = 0; i < 5; i++)
        {
            while(deviceGeneratedCode[i] != 0x30 && deviceGeneratedCode[i] != 0x31
                && deviceGeneratedCode[i] != 0x32 && deviceGeneratedCode[i] != 0x33 
                && deviceGeneratedCode[i] != 0x34 && deviceGeneratedCode[i] != 0x35
                && deviceGeneratedCode[i] != 0x36 && deviceGeneratedCode[i] != 0x37 
                && deviceGeneratedCode[i] != 0x38 && deviceGeneratedCode[i] != 0x39)
            {
                deviceGeneratedCode[i] = GenerateRandomNumber();
            }
            // These two following rows are here only to take time for the random numbers
            lcdSend(L_CLR, COMMAND);
            lcdPrint("Wait...");
        }
        
        
        RS485_TxEnable();
        UART_Write(myUniqueId); // Print my own unique identifier
        messageType = 0x01;     // Here the message is type 1 (first message)
        UART_Write(messageType); 
        // Device generated code
        lcdSend(L_CLR, COMMAND);
        for (int i = 0; i < 5; i++)
        {
            UART_Write(deviceGeneratedCode[i]);
            lcdSend(L_L1 + i, COMMAND);
            lcdSend(deviceGeneratedCode[i], DATA);
        }
        UART_Write('*');    // Stopping symbol
        
        
        // Now we listen to the keypad and wait for the user to insert a code
        lcdSend(L_L2, COMMAND);
        lcdPrint("Insert: ");
        while(codeFromKeypadIndex != 5)
        {
            KeyPadReader();
        }
        // Now we send the code via serial
        RS485_TxEnable();
        UART_Write(myUniqueId); // Print my own unique identifier
        messageType = 0x02;     // Here the message is type 1 (first message)
        UART_Write(messageType);
        // Device generated code
        for (int i = 0; i < 5; i++)
        {
            UART_Write(deviceGeneratedCode[i]);
        }
        // Code inserted by user
        for (int i = 0; i < 5; i++)
        {
            UART_Write(codeFromKeypad[i]);
        }
        UART_Write('*');    // Stopping symbol
        
        
        // Enable receiving
        RS485_RxEnable();
        
        while(bufferIndex < 4)
        {
            // Wait
            UART_Read();
            lcdSend(L_L2, COMMAND);
            lcdPrint("Wait for data");
        }
        lcdSend(L_L2, COMMAND);
        lcdPrint("Done!");
        
        checkMessage();
        
        lcdSend(L_L2, COMMAND);
        lcdPrint("Press # to exit");
        while(!resetGlobalVariables)
        {
            KeyPadReader();
        }
        // Then reset the global variables
        ResetGlobalVariables();
    }
}

void ResetGlobalVariables()
{     
    // Reset received
    received = 0;

    // Reset buffer
    bufferIndex = 0;
    for (int i = 0; i < 50; i++)
    {
        buffer[i] = '\0';
    }

    // Reset deviceGeneratedCode
    deviceGeneratedCodeIndex = 0;
    for (int i = 0; i < 5; i++)
    {
        deviceGeneratedCode[i] = '\0';
    }

    // Code inserted on keypad by user
    codeFromKeypadIndex = 0;
    for (int i = 0; i < 5; i++)
    {
        codeFromKeypad[i] = '\0';
    }

    // Reset the space line for second row
    secondLineLcdPosition = 9;

    // Reset global variables value
    resetGlobalVariables = 0;

    // Reset start
    start = 0;
}

void checkMessage() {
            
    if (buffer[0] == myUniqueId && buffer[1] == gatewayId)
    {
        //lcdSend(L_L1, COMMAND);
        //lcdPrint("Weyyyy!");
        
       
        // This message is for me
        if (buffer[3] == openDoorCode)
        {
            lcdSend(L_L1, COMMAND);
            lcdPrint("Door Open!");
        }
        else if (buffer[3] == doNotOpenDoorCode)
        {
            lcdSend(L_L1, COMMAND);
            lcdPrint("Can't open,sorry");
        }
        
        
    }
    // Else ignore
}

void UART_Init() {
    // Configure UART module
    TRISC6 = 0;     // TX pin is output
    TRISC7 = 1;     // RX pin is input

    // Set baud rate to 9600
    BRGH = 1;       // High speed baud rate
    SPBRG = 51;     // Value for 9600 baud rate (Fosc = 8MHz)

    // Enable asynchronous serial port
    SYNC = 0;       // Asynchronous mode
    SPEN = 1;       // Serial port enabled

    // Enable transmission and reception
    TXEN = 1;       // Transmission enabled
    CREN = 1;       // Reception enabled
}

void RS485_TxEnable() {
    RS485_TX_EN = 1;
    RS485_RX_EN = 0;
}

void RS485_RxEnable() {
    RS485_TX_EN = 0;
    RS485_RX_EN = 1;
}

void UART_Write(char data) {
    while (!TXIF) // Wait for the previous transmission to finish
        continue;
    TXREG = data; // Transmit data
}

void UART_Read() {
    while (!PIR1bits.RCIF) // Wait until data is received
        continue;
    buffer[bufferIndex++] = RCREG;
    //buffer[bufferIndex] = '\0';
    received = 1;
    //lcdSend(L_CLR, COMMAND);
    //lcdSend(L_L2, COMMAND);
    //lcdPrint("Arrivato");
}

void __interrupt() ISR() {
    
    /*
    if(RCIF)
    {
        buffer[bufferIndex++] = RCREG;
    }
     * */
        
    TMR0IF = 0;
    
}

void Timer0_Init() {
    // Configure Timer0
    T0CS = 0;    // Use internal instruction clock
    PSA = 0;     // Assign prescaler to Timer0
    PS2 = 1;     // Set prescaler to 1:256
    PS1 = 1;
    PS0 = 1;

    // Enable Timer0
    TMR0 = 6;    // Clear Timer0
    TMR0IF = 0;  // Clear Timer0 overflow flag
    TMR0IE = 1;  // Disable Timer0 interrupt
    GIE = 1;
}

unsigned char GenerateRandomNumber() {
    unsigned int count = 0;
    while (count != 186){
        count++;
    }
    unsigned char randomNum = TMR0;
    TMR0IF = 0;
    return randomNum;
}

void KeyPadReader()
{
    TRISD |= 0x0F;
    
    for (colScan = 0; colScan < 3; colScan++)
    {
        PORTB = PORTB | 0x07;
        PORTB &= colMask[colScan];

        for (rowScan=0; rowScan < 4; rowScan++)
        {
            if(!(PORTD & rowMask[rowScan]) && (old_btn))
            {
                old_btn = 0;
                stato++;
            }
            if((PORTD & rowMask[rowScan]) && (!old_btn))
            {
                __delay_ms(10);
                if((PORTD & rowMask[rowScan]) && (!old_btn))
                {
                    old_btn = 1;
                }
            }
            if(stato != old_stato)
            {
                keypressed = rowScan + (4 * colScan); // numero di pulsante premuto
                // chiamo la funzione
                KeyPressed(keypressed);
                old_stato = stato;
            }

        }
        //------------------------------------------------------------------
    }
}

void KeyPressed(unsigned char keypressed)
{
    if (keys[keypressed] == '*')
    {
        start = 1;
    }
    else if (keys[keypressed] == '=')
    {
        resetGlobalVariables = 1;
    }
    else if (start)
    {
        codeFromKeypad[codeFromKeypadIndex] = keys[keypressed];
        // First print the inserted number
        lcdSend(L_L2 + secondLineLcdPosition++, COMMAND);
        lcdSend(codeFromKeypad[codeFromKeypadIndex], DATA);
        // Second increase the index
        codeFromKeypadIndex++;
    }
    
    
    
    __delay_ms(200);
    
    // rimango in un ciclo continuo fino a che
    // il pulsante non viene rilasciato
    PORTD = PORTD | 0x0F;
    while((PORTD & 0x0F) != 0x0F)
    {
        PORTD = PORTD | 0x0F;
        continue;
    }
    
}


void initLCD() {
    LCD_RS = 0;
    LCD_EN = 0;
    __delay_ms(20);
    LCD_EN = 1;
    lcdSend(L_CFG, COMMAND);
    __delay_ms(5);
    lcdSend(L_CFG, COMMAND);
    __delay_ms(1);
    lcdSend(L_CFG, COMMAND);
    lcdSend(L_OFF, COMMAND);
    lcdSend(L_ON, COMMAND);
    lcdSend(L_CLR, COMMAND);
    lcdSend(L_NCR, COMMAND);
    lcdSend(L_L1, COMMAND);
}

void lcdSend(char dato, char tipo) {
    LCDPORT_DIR = 0x00;
    LCD_EN_DIR = 0;
    LCD_RS_DIR = 0;

    LCD_EN = 1;
    LCDPORT = dato;
    LCD_RS = tipo;
    LCD_EN = 0;
    LCD_EN = 1;
}

void lcdPrint(char *str) {
    int n = 0;
    while (str[n] != '\0') {
        lcdSend(str[n++], DATA);
    }
}


char potenza(char b, char e) {
    char n = 1;
    for (int i = 0; i < e; i++) {
        n = n * b;
    }
    return n;
}

void intToString(int n, char *str) {

    char cifre = 1;
    char i = 0;
    
    while (n / potenza(10, cifre)) cifre++;

    for (i = 0; i < cifre; i++) {
        char t = potenza(10, cifre - 1 - i);
        str[i] = '0' + (char) (n / t);
        n = n % t;
    }

    str[i] = '\0';
}
